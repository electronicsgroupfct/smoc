# -*- coding: utf-8 -*-
"""Genetic algrithm using DEAP"""

import array
import copy
import math
import random
\
from deap import algorithms, base, creator, tools
from profilehooks import timecall

from paim.util import plot as plt

#                          0   1        2               3     4
# Genes de um individuo - W1, W2 (=WB), L (=L1=L2=LB), Ib, Vbias(=VGS1)
IND_SIZE = 5

BOUND_LOW = [1e-6,   1e-6,   120e-9,     1e-6,   0.3]
BOUND_UP = [100e-6, 100e-6, (4*120e-9), 100e-6, 0.7]

# Constraints
VDSAT_MIN = 80e-3
VDSAT_MAX = 200e-3
VDS_SAT_MIN = 50e-3
GBW_MIN = 10e6
GAIN_MIN = 30
OS_MIN = 0.7


def uniform(low, up):
    """Generate a random number between "low" and "up"

    Arguments:
        low {number} -- lower bound
        up {number} -- upper bound

    Returns:
        {float} -- Generated number
    """
    return [random.uniform(a, b) for a, b in zip(low, up)]


############################################################
# Equations

def gm(Id, VDsat):
    return (2 * Id) / VDsat


def VDsat(Id, W, L, K):
    return math.sqrt((2 * Id * L) / (W * K))


def gds(Id, L, k):
    return Id / ((k / 1e-3) * L)


def gain(gm, gds1, gds2):
    return 20 * math.log10(gm / (gds1 + gds2))


def GBW(gm, Cout):
    return gm / (2 * math.pi * Cout)


def power(Vdd, Id):
    return Vdd * 2 * Id

def OS(Vdd, Vdsat):
    Vmargin = 50e-3 * len(Vdsat)
    
    return Vdd - sum(Vdsat) - Vmargin

#Variables
VDD = 1.2
VTn = 0.38
VTp = 0.33
KN = 500e-6
KP = 100e-6
############################################################

def eval_circuit(individual):
    """Evaluate the circuit by performing simulation with the provided "individual"

    Arguments:
        individual {list} -- the individual to be evaluated

    Returns:
        p {float} -- power consumption
        g {float} -- DC gain
    """
    # TODO: Avaliar através de simulação
    vdsat1 = VDsat(individual[3], individual[0], individual[2], KN)
    vdsat2 = VDsat(individual[3], individual[1], individual[2], KP)
    gm1 = gm(individual[3], vdsat1)
    gdsN = gds(individual[3], individual[2], 8311)
    gdsP = gds(individual[3], individual[2], 10670)

    # Consumo
    p = power(VDD, individual[3])

    # Ganho
    g = gain(gm1, gdsN, gdsP)

    return p, g    # Aqui a ordem tem de corresponder à definida no fitness


def feasibility(individual):
    """Feasibility function for the individual

    Arguments:
        individual {list} -- the individual to be evaluated

    Returns:
        {boolean} -- True if feasible False otherwise
    """
    vdsat1 = VDsat(individual[3], individual[0], individual[2], KN)
    vdsat2 = VDsat(individual[3], individual[1], individual[2], KP)
    gm1 = gm(individual[3], vdsat1)
    gdsN = gds(individual[3], individual[2], 8311)
    gdsP = gds(individual[3], individual[2], 10670)

    if (GBW(gm1, 10e-12) >= GBW_MIN) and (gain(gm1, gdsN, gdsP) >= GAIN_MIN) and (VDSAT_MIN <= vdsat1 < VDSAT_MAX) and (VDSAT_MIN <= vdsat2 < VDSAT_MAX) and (OS(1.2, [vdsat1, vdsat2]) >= OS_MIN):
        return True
    return False


def distance(individual):
    """A distance function to the feasibility region

    Arguments:
        individual {list} -- the individual to be evaluated

    Returns:
        {float} -- distance function between an invalid individual and the valid region
    """
    vdsat1 = VDsat(individual[3], individual[0], individual[2], KN)
    vdsat2 = VDsat(individual[3], individual[1], individual[2], KP)
    gm1 = gm(individual[3], vdsat1)
    gdsN = gds(individual[3], individual[2], 8311)
    gdsP = gds(individual[3], individual[2], 10670)

    gbw = GBW(gm1, 10e-12)
    g = gain(gm1, gdsN, gdsP)
    os = OS(1.2, [vdsat1, vdsat2])

    if gbw < GBW_MIN:
        return (gbw - GBW_MIN)**2

    if g < GAIN_MIN:
        return (g - GAIN_MIN)**2

    if VDSAT_MAX < vdsat1 < VDSAT_MIN:
        return (vdsat1 - VDSAT_MIN)**2

    if VDSAT_MAX < vdsat2 < VDSAT_MIN:
        return (vdsat2 - VDSAT_MIN)**2
    # OS
    return (os - OS_MIN)**2

@timecall
def myEaMuPlusLambda(population, toolbox, mu, lambda_, cxpb, mutpb, ngen,
                     stats=None, halloffame=None, verbose=__debug__):
    """This is the (mu + lambda) evolutionary algorithm.
    ADAPTED FROM: https://github.com/DEAP/deap/blob/master/deap/algorithms.py

    The pseudocode goes as follow ::
        evaluate(population)
        for g in range(ngen):
            offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)
            evaluate(offspring)
            population = select(population + offspring, mu)
    First, the individuals having an invalid fitness are evaluated. Second,
    the evolutionary loop begins by producing *lambda_* offspring from the
    population, the offspring are generated by the :func:`varOr` function. The
    offspring are then evaluated and the next generation population is
    selected from both the offspring **and** the population. Finally, when
    *ngen* generations are done, the algorithm returns a tuple with the final
    population and a :class:`~deap.tools.Logbook` of the evolution.
    This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,
    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be
    registered in the toolbox. This algorithm uses the :func:`varOr`
    variation.
    """
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

    # Evaluate the individuals with an invalid fitness
    invalid_ind = [ind for ind in population if not ind.fitness.valid]
    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit

    if halloffame is not None:
        halloffame.update(population)

    record = stats.compile(population) if stats is not None else {}
    logbook.record(gen=0, nevals=len(invalid_ind), **record)

    # if verbose:
    #    print logbook.stream

    # Begin the generational process
    for gen in range(1, ngen + 1):
        # Vary the population
        offspring = algorithms.varOr(population, toolbox, lambda_, cxpb, mutpb)

        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        # Update the hall of fame with the generated individuals
        if halloffame is not None:
            halloffame.update(offspring)

        # Select the next generation population
        population[:] = toolbox.select(population + offspring, mu)

        # Update the statistics with the new population
        record = stats.compile(population) if stats is not None else {}
        logbook.record(gen=gen, nevals=len(invalid_ind), **record)
        if verbose and not (gen % 5):   # Only prints multiples of 5 gens
            # print(logbook.stream)
            print(f"---- Gen: {gen} \t| # Evals: {len(invalid_ind)} -----")

    return population, logbook


def main():
    """Main function
    """
    ### SÓ PARA TESTES
    random.seed(64)

    # Registar os atributos dos indivuos e da população
    toolbox = base.Toolbox()

    toolbox.pop_size = 200
    toolbox.max_gen = 50
    toolbox.cx_prob = 0.8  # 0.9
    toolbox.mut_prob = 0.1  # 0.03

    # Creator
    creator.create("FitnessMulti", base.Fitness, weights=(-1.0, 1.0))
    creator.create("Individual", array.array, typecode='d',
                   fitness=creator.FitnessMulti)

    # float gerado aleatoriamente
    toolbox.register("attr_float", uniform, BOUND_LOW, BOUND_UP)
    # Define individuo como a lista de floats (itera pelo "attr_float" e coloca o resultado no "creator.Individual")
    toolbox.register("individual", tools.initIterate,
                     creator.Individual, toolbox.attr_float)
    # Define a população como uma lista de individuos (o nro de individuos só é definido quando se inicializa a pop)
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)

    # Generic Operators
    # register the goal / fitness function
    toolbox.register("evaluate", eval_circuit)
    toolbox.decorate("evaluate", tools.DeltaPenalty(feasibility, 0, distance))

    # register the crossover operator
    toolbox.register("mate", tools.cxSimulatedBinaryBounded,
                     low=BOUND_LOW, up=BOUND_UP, eta=20.0)

    # register the mutation operator
    toolbox.register("mutate", tools.mutPolynomialBounded,
                     low=BOUND_LOW, up=BOUND_UP, eta=20.0, indpb=toolbox.mut_prob)

    # operator for selecting individuals for breeding the next generation
    toolbox.register("select", tools.selNSGA2)

    # Create the population
    pop = toolbox.population(n=toolbox.pop_size)
    pop = toolbox.select(pop, len(pop))

    # Create the statistics
    stats = tools.Statistics()
    stats.register("pop", copy.deepcopy)

    # Verbosity
    verbose = True

    # Run the simulation
    res_pop, logbook = myEaMuPlusLambda(pop, toolbox, mu=toolbox.pop_size,
                                        lambda_=toolbox.pop_size, cxpb=toolbox.cx_prob,
                                        mutpb=toolbox.mut_prob, stats=stats,
                                        ngen=toolbox.max_gen, verbose=verbose)

    # Get the pareto fronts
    fronts = tools.emo.sortLogNondominated(res_pop, len(res_pop))

    # Print statistics
    plt.plot_pareto_fronts(fronts, toolbox.evaluate)

    # plt.plot_pareto_fronts_animated(logbook, toolbox.evaluate, tools.emo.sortLogNondominated)

    input("cenas")

if __name__ == "__main__":
    main()
